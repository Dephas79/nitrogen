#!/usr/bin/env escript
%% -*- erlang -*-
%% vim: ts=4 sw=4 et ft=erlang
%%
%% Coyright 2021 - Jesse Gumm
%% MIT License
%%
%%
%% Usage: ./add_relx_to_rebar3.escript [rebar.config]
%%
%% Takes the target rebar.config, analyzes the deps, and adds a relx item to it

main([]) ->
    main(["rebar.config"]);
main([File]) ->
    Config = case file:consult(File) of
        {error, Reason} ->
            io:format("FAIL! Reason: ~p~n",[Reason]),
            halt(1);
        {ok, X} ->
            X
    end,
    C2 = remove_option(sub_dirs, Config),
    C3 = remove_option(deps_dir, C2),
    C4 = remove_sub_option(erl_opts, i, C3),
    C5 = add_plugins(C4),
    C6 = add_relx(C5),
    case C6==Config of
        true ->
            io:format("No changes were made to ~s~n",[File]);
        false ->
            Formatted = writable_terms(C6),
            io:format("Writing new ~s~n",[File]),
            file:write_file(File, Formatted)
    end.

add_plugin(Plugin, Config) ->
    io:format("Adding plugin ~p: ",[Plugin]),
    Plugins = proplists:get_value(plugins, Config, []),
    case lists:member(Plugin, Plugins) of
        true ->
            io:format("already present, skipping~n"),
            Config;
        false ->
            NewPlugins = [Plugin | Plugins],
            C2 = lists:keydelete(plugins, 1, Config),
            io:format("added~n"),
            [{plugins, NewPlugins} | C2]
    end.

writable_terms(Terms) ->
    lists:map(fun(Term) ->
        io_lib:format("~p.~n~n", [Term])
    end, Terms).

remove_sub_option(Rule, Subrule, Config) ->
    io:format("Removing ~p/~p rule (if it exists): "),
    case lists:keyfind(Rule, 1 Config) of
        false ->
            io:format("~p does not exist, skipping.~n",[Rule]),
            Config;
        {Rule, Opts} ->
            case lists:keyfind(Subrule, 1, Opts) of
                false ->
                    io:format("NO, ~p exists, but no ~p option inside, skipping.~n",[Rule, Subrule]),
                    Config;
                {Subrule, _} ->
                    io:format("YES, exists, removing~n"),
                    NewOpts = lists:keydelete(Subrule, 1, Opts),
                    NewConfig = lists:keydelete(Rule, 1, Config),
                    NewRule = {Rule, NewOpts},
                    [NewRule | NewConfig]
            end
    end.
            


remove_option(Rule, Config) ->
    io:format("Removing ~p rule (if it exists): ", [Rule]),
    case lists:keyfind(Rule, 1, Config) of
        false ->
            io:format("NO, does not exist, skipping.~n"),
            Config;
        _ ->
            io:format("YES, exists, removing.~n"),
            lists:keydelete(Rule, 1, Config)
    end.

add_relx(Config) ->
    io:format("Adding Relx config.~n"),
    Relx = proplists:get_value(relx, Config, undefined),
    case Relx of
        undefined ->
            add_relx_inner(Config);
        _ ->
            io:format("Target file already has relx rules. Aborting.~n"),
            Config
    end.

add_relx_inner(Config) ->
    Deps = proplists:get_value(deps, Config, []),
    
    Apps = lists:map(fun
        (App) when is_atom(App) ->
            App;
        (App) when is_tuple(App) ->
            element(1, App)
    end, Deps),

    Applines = lists:map(fun(App) ->
        {App, load}
    end, Apps),

    NewRelx = {relx, [
        {release, {nitrogen, "0.0.1"}, [
            sasl, Applines, nitrogen
        ]},
        {sys_config, "etc/autogenerated.config.all"},
        {vm_args, "etc/vm.args"},
        {dev_mode, true},
        {mode, dev},
        {include_erts, false},
        {extended_start_script, true},
        {overlay, [
            {copy, "site", "site"},
            {copy, "priv", "priv"}
        ]}
    ]},
    Config ++ [NewRelx].
